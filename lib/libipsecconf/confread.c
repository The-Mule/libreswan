/* Libreswan config file parser (confread.c)
 * Copyright (C) 2001-2002 Mathieu Lafon - Arkoon Network Security
 * Copyright (C) 2004 Xelerance Corporation
 * Copyright (C) 2006-2008 Michael Richardson <mcr@xelerance.com>
 * Copyright (C) 2007 Ken Bantoft <ken@xelerance.com>
 * Copyright (C) 2006-2012 Paul Wouters <paul@xelerance.com>
 * Copyright (C) 2010 Michael Smith <msmith@cbnco.com>
 * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi>
 * Copyright (C) 2012-2019 Paul Wouters <pwouters@redhat.com>
 * Copyright (C) 2012 Avesh Agarwal <avagarwa@redhat.com>
 * Copyright (C) 2012 Antony Antony <antony@phenome.org>
 * Copyright (C) 2013 Florian Weimer <fweimer@redhat.com>
 * Copyright (C) 2013 David McCullough <ucdevel@gmail.com>
 * Copyright (C) 2013-2019 D. Hugh Redelmeier <hugh@mimosa.com>
 * Copyright (C) 2016 Andrew Cagney <cagney@gnu.org>
 * Copyright (C) 2017-2018 Vukasin Karadzic <vukasin.karadzic@gmail.com>
 * Copyright (C) 2017 Mayank Totale <mtotale@gmail.com>
 * Copyright (C) 2020 Yulia Kuzovkova <ukuzovkova@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.  See <https://www.gnu.org/licenses/gpl2.txt>.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 */

#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <sys/socket.h>		/* for AF_UNSPEC */

#include "lswalloc.h"
#include "ip_address.h"
#include "ip_info.h"
#include "hunk.h"		/* for char_is_space() */
#include "ip_cidr.h"
#include "ttodata.h"

#include "ipsecconf/parser.h"
#include "ipsecconf/confread.h"
#include "ipsecconf/interfaces.h"

#include "ipsecconf/keywords.h"
#include "ipsecconf/parser.h"	/* includes parser.tab.h generated by bison; requires keywords.h */

#include "whack.h" /* for DEFAULT_CTL_SOCKET */
#include "lswlog.h"

const char *rootdir;	/* when evaluating paths, prefix this to them */
const char *rootdir2;	/* or... try this one too */

static bool translate_conn(struct starter_conn *conn,
			   const struct config_parsed *cfgp,
			   struct section_list *sl,
			   enum keyword_set assigned_value,
			   struct logger *logger);

/**
 * Set up hardcoded defaults, from data in programs/pluto/constants.h
 *
 * @param cfg starter_config struct
 * @return void
 */

static struct starter_config *alloc_starter_config(void)
{
	struct starter_config *cfg = alloc_thing(struct starter_config, "starter_config cfg");

	static const struct starter_config empty_starter_config;	/* zero or null everywhere */
	*cfg = empty_starter_config;

	TAILQ_INIT(&cfg->conns);

	/* ==== config setup ==== */

# define SOPT(kbf, v)  { cfg->setup[kbf].option = (v) ; }

	SOPT(KBF_LOGTIME, true);
	SOPT(KBF_LOGAPPEND, true);
	SOPT(KBF_LOGIP, true);
	SOPT(KBF_AUDIT_LOG, true);
	SOPT(KBF_UNIQUEIDS, true);
	SOPT(KBF_LISTEN_UDP, true);
	SOPT(KBF_DO_DNSSEC, true);
	SOPT(KBF_IKEBUF, IKE_BUF_AUTO);
	SOPT(KBF_IKE_ERRQUEUE, true);
	SOPT(KBF_NHELPERS, -1); /* see also plutomain.c */

	SOPT(KBF_DDOS_IKE_THRESHOLD, DEFAULT_IKE_SA_DDOS_THRESHOLD);
	SOPT(KBF_MAX_HALFOPEN_IKE, DEFAULT_MAXIMUM_HALFOPEN_IKE_SA);
	/* Don't inflict BSI requirements on everyone */
	SOPT(KBF_GLOBAL_IKEv1, GLOBAL_IKEv1_DROP);

	SOPT(KBF_DDOS_MODE, DDOS_AUTO);

	SOPT(KBF_OCSP_CACHE_SIZE, OCSP_DEFAULT_CACHE_SIZE);

	SOPT(KBF_SECCOMP, SECCOMP_DISABLED); /* will be enabled in the future */

# undef SOPT

	cfg->setup[KSF_PLUTO_DNSSEC_ROOTKEY_FILE].string = clone_str(DEFAULT_DNSSEC_ROOTKEY_FILE, "default dnssec rootkey file");
	cfg->setup[KSF_NSSDIR].string = clone_str(IPSEC_NSSDIR, "default ipsec nssdir");
	cfg->setup[KSF_SECRETSFILE].string = clone_str(IPSEC_SECRETS, "default ipsec.secrets file");
	cfg->setup[KSF_DUMPDIR].string = clone_str(IPSEC_RUNDIR, "default dumpdir");
	cfg->setup[KSF_IPSECDIR].string = clone_str(IPSEC_CONFDDIR, "default ipsec.d dir");

	/* ==== end of config setup ==== */

	/* ==== conn %default ==== */

	struct starter_conn *d = &cfg->conn_default;

# define DOPT(kbf, v)  { d->values[kbf].option = (v); }

	DOPT(KNCF_TYPE, KS_TUNNEL);
	DOPT(KNCF_AUTO, AUTOSTART_IGNORE);

# undef DOPT

	d->end[LEFT_END].leftright = "left";
	d->end[RIGHT_END].leftright = "right";

	d->state = STATE_LOADED;
	/* ==== end of conn %default ==== */

	return cfg;
}

/**
 * Load a parsed config
 *
 * @param cfg starter_config structure
 * @param cfgp config_parsed (ie: valid) struct
 * @param perr pointer to store errors in
 */
static bool load_setup(struct starter_config *cfg,
		       const struct config_parsed *cfgp)
{
	bool ok = true;
	const struct kw_list *kw;

	for (kw = cfgp->config_setup; kw != NULL; kw = kw->next) {
		/**
		 * the parser already made sure that only config keywords were used,
		 * but we double check!
		 */
		assert(kw->keyword.keydef->validity & kv_config);
		unsigned f = kw->keyword.keydef->field;

		switch (kw->keyword.keydef->type) {
		case kt_string:
		case kt_filename:
		case kt_dirname:
		case kt_host:
			/* all treated as strings for now */
			assert(f < elemsof(cfg->setup));
			pfreeany(cfg->setup[f].string);
			cfg->setup[f].string =
				clone_str(kw->string, "kt_loose_enum kw->string");
			cfg->setup[f].set = true;
			break;

		case kt_lset:
		case kt_bool:
		case kt_sparse_name:
		case kt_unsigned:
		case kt_binary:
			/* all treated as a number for now */
			assert(f < elemsof(cfg->setup));
			cfg->setup[f].option = kw->number;
			cfg->setup[f].set = true;
			break;

		case kt_seconds:
		case kt_milliseconds:
			/* all treated as a number for now */
			assert(f < elemsof(cfg->setup));
			cfg->setup[f].deltatime = kw->deltatime;
			cfg->setup[f].set = true;
			break;

		case kt_bitstring:
		case kt_pubkey:
		case kt_ipaddr:
		case kt_subnet:
		case kt_range:
		case kt_idtype:
			ok = false;
			break;

		case kt_also:
		case kt_appendstring:
		case kt_appendlist:
		case kt_obsolete:
			break;

		}
	}

	return ok;
}

/**
 * Validate that yes in fact we are one side of the tunnel
 *
 * The function checks that IP addresses are valid, nexthops are
 * present (if needed) as well as policies, and sets the leftID from
 * the left= if it isn't set.
 *
 * @param conn_st a connection definition
 * @param end a connection end
 * @param leftright const char * "left" or "right"
 * @param perrl pointer to starter_errors_t
 * @return bool TRUE if failed
 */

static bool validate_end(struct starter_conn *conn_st,
			 struct starter_end *end,
			 struct logger *logger)
{
	bool ok = true;
	const char *leftright = end->leftright;
	const struct ip_info *host_afi = conn_st->host_afi;

	passert(host_afi != NULL);
	pexpect(host_afi == &ipv4_info || host_afi == &ipv6_info); /* i.e., not NULL */

#  define ERR_FOUND(...) { llog(RC_LOG, logger, __VA_ARGS__); ok = false; }

	if (!end->values[KW_IP].set)
		conn_st->state = STATE_INCOMPLETE;

	/* validate the KSCF_IP/KNCF_IP */
	end->resolve.host.name = end->values[KW_IP].string;
	end->resolve.host.type = end->values[KW_IP].option;
	switch (end->resolve.host.type) {
	case KH_ANY:
		end->resolve.host.addr = unset_address;
		break;

	case KH_IFACE:
		/* generally, this doesn't show up at this stage */
		ldbg(logger, "starter: %s is KH_IFACE", leftright);
		break;

	case KH_IPADDR:
		assert(end->values[KW_IP].string != NULL);

		if (end->values[KW_IP].string[0] == '%') {
			const char *iface = end->resolve.host.name + 1;
			if (!starter_iface_find(iface, host_afi,
						&end->resolve.host.addr,
						&end->resolve.nexthop.addr))
				conn_st->state = STATE_INVALID;
			/* not numeric, so set the type to the iface type */
			end->resolve.host.type = KH_IFACE;
			break;
		}

		err_t er = ttoaddress_num(shunk1(end->resolve.host.name),
					  host_afi, &end->resolve.host.addr);
		if (er != NULL) {
			/* not an IP address, so set the type to the string */
			end->resolve.host.type = KH_IPHOSTNAME;
		} else {
			pexpect(host_afi == address_info(end->resolve.host.addr));
		}

		break;

	case KH_OPPO:
	case KH_OPPOGROUP:
	case KH_GROUP:
		/* handled by pluto using .host_type */
		break;

	case KH_IPHOSTNAME:
		/* generally, this doesn't show up at this stage */
		ldbg(logger, "starter: %s is KH_IPHOSTNAME", leftright);
		break;

	case KH_DEFAULTROUTE:
		ldbg(logger, "starter: %s is KH_DEFAULTROUTE", leftright);
		break;

	case KH_NOTSET:
		/* cannot error out here, it might be a partial also= conn */
		break;
	}

	/*
	 * validate the KSCF_NEXTHOP; set nexthop address to
	 * something consistent, by default
	 */
	end->resolve.nexthop.addr = host_afi->address.unspec;
	end->resolve.nexthop.name = end->values[KW_NEXTHOP].string;
	if (end->resolve.nexthop.name != NULL) {
		const char *value = end->resolve.nexthop.name;
		if (strcaseeq(value, "%defaultroute")) {
			end->resolve.nexthop.type = KH_DEFAULTROUTE;
		} else {
			err_t e = ttoaddress_num(shunk1(value), host_afi,
						 &end->resolve.nexthop.addr);
			if (e != NULL) {
				ERR_FOUND("bad value for %snexthop=%s [%s]",
					  leftright, value, e);
			}
			end->resolve.nexthop.type = KH_IPADDR;
		}
	} else {
		end->resolve.nexthop.addr = host_afi->address.unspec;

		if (end->resolve.host.type == KH_DEFAULTROUTE) {
			end->resolve.nexthop.type = KH_DEFAULTROUTE;
		}
	}

	return ok;
#  undef ERR_FOUND
}

bool confread_validate_conn(struct starter_conn *conn, struct logger *logger)
{
	bool ok = true;
	ok &= validate_end(conn, &conn->end[LEFT_END], logger);
	ok &= validate_end(conn, &conn->end[RIGHT_END], logger);
	return ok;
}

bool confread_validate_conns(struct starter_config *config, struct logger *logger)
{
	bool ok = true;
	struct starter_conn *conn;
	TAILQ_FOREACH(conn, &config->conns, link) {
		if (conn->state == STATE_LOADED) {
			ok &= confread_validate_conn(conn, logger);
		}
	}
	return ok;
}

/**
 * Take keywords from ipsec.conf syntax and load into a conn struct
 *
 * @param conn a connection definition
 * @param sl a section_list
 * @param assigned_value is set to either k_set, or k_default.
 *        k_default is used when we are loading a conn that should be
 *        considered to be a "default" value, and that replacing this
 *        value is considered acceptable.
 * @return bool TRUE if unsuccessful
 */

static bool translate_field(struct starter_conn *conn,
			    const struct config_parsed *cfgp,
			    const struct section_list *sl,
			    enum keyword_set assigned_value,
			    const struct kw_list *kw,
			    const char *leftright,
			    keyword_values values,
			    struct logger *logger)
{
	bool ok = true;

	unsigned int field = kw->keyword.keydef->field;

	assert(kw->keyword.keydef != NULL);

	switch (kw->keyword.keydef->type) {
	case kt_also:
	{
		struct section_list *addin;
		const char *seeking = kw->string;
		TAILQ_FOREACH(addin, &cfgp->sections, link) {
			if (streq(seeking, addin->name)) {
				break;
			}
		}
		if (addin == NULL) {
			llog(RC_LOG, logger,
			     "cannot find conn '%s' needed by conn '%s'",
			     seeking, conn->name);
			ok = false;
			break;
		}
		/* translate things, but do not replace earlier settings! */
		ok &= translate_conn(conn, cfgp, addin, k_set, logger);
		break;
	}
	case kt_string:
	case kt_filename:
	case kt_dirname:
	case kt_bitstring:
	case kt_ipaddr:
	case kt_range:
	case kt_subnet:
	case kt_idtype:
		/* all treated as strings for now, even loose enums */
		if (values[field].set == k_set) {
			llog(RC_LOG, logger,
			     "duplicate key '%s%s' in conn %s while processing def %s",
			     leftright, kw->keyword.keydef->keyname,
			     conn->name,
			     sl->name);

			/* only fatal if we try to change values */
			if (kw->keyword.string == NULL ||
			    values[field].string == NULL ||
			    !streq(kw->keyword.string,
				   values[field].string))
			{
				ok = false;
				break;
			}
		}
		pfreeany(values[field].string);

		if (kw->string == NULL) {
			llog(RC_LOG, logger, "invalid %s value",
			     kw->keyword.keydef->keyname);
			ok = false;
			break;
		}

		values[field].string = clone_str(kw->string, "kt_idtype kw->string");
		values[field].set = assigned_value;
		break;

	case kt_appendstring:
	case kt_appendlist:
		/* implicitly, this field can have multiple values */
		if (values[field].string == NULL) {
			values[field].string = clone_str(kw->string, "kt_appendlist kw->string");
		} else {
			char *s = values[field].string;
			size_t old_len = strlen(s);	/* excludes '\0' */
			size_t new_len = strlen(kw->string);
			char *n = alloc_bytes(old_len + 1 + new_len + 1, "kt_appendlist");

			memcpy(n, s, old_len);
			n[old_len] = ' ';
			memcpy(n + old_len + 1, kw->string, new_len + 1);	/* includes '\0' */
			values[field].string = n;
			pfree(s);
		}
		values[field].set = true;
		break;

	case kt_pubkey:
	case kt_host:
		if (values[field].set == k_set) {
			llog(RC_LOG, logger,
			     "duplicate key '%s%s' in conn %s while processing def %s",
			     leftright, kw->keyword.keydef->keyname,
			     conn->name,
			     sl->name);

			/* only fatal if we try to change values */
			if (values[field].option != (int)kw->number ||
			    !(values[field].option ==
			      LOOSE_ENUM_OTHER &&
			      kw->number == LOOSE_ENUM_OTHER &&
			      kw->keyword.string != NULL &&
			      values[field].string != NULL &&
			      streq(kw->keyword.string,
				    values[field].string)))
			{
				ok = false;
				break;
			}
		}

		values[field].option = kw->number;
		if (kw->number == LOOSE_ENUM_OTHER) {
			assert(kw->string != NULL);
			pfreeany(values[field].string);
			values[field].string = clone_str(
				kw->string, "kt_loose_enum kw->keyword.string");
		}
		values[field].set = assigned_value;
		break;

	case kt_lset:
	case kt_bool:
	case kt_sparse_name:
	case kt_unsigned:
	case kt_binary:
		/* all treated as a number for now */
		if (values[field].set == k_set) {
			llog(RC_LOG, logger,
			     "duplicate key '%s%s' in conn %s while processing def %s",
			     leftright, kw->keyword.keydef->keyname,
			     conn->name,
			     sl->name);

			/* only fatal if we try to change values */
			if (values[field].option != (int)kw->number) {
				ok = false;
				break;
			}
		}

		values[field].option = kw->number;
		values[field].set = assigned_value;
		break;

	case kt_seconds:
	case kt_milliseconds:
		/* all treated as a number for now */
		if (values[field].set == k_set) {
			llog(RC_LOG, logger,
			     "duplicate key '%s%s' in conn %s while processing def %s",
			     leftright, kw->keyword.keydef->keyname,
			     conn->name,
			     sl->name);

			/* only fatal if we try to change values */
			if (deltatime_cmp(values[field].deltatime, !=, kw->deltatime)) {
				ok = false;
				break;
			}
		}

		values[field].deltatime = kw->deltatime;
		values[field].set = assigned_value;
		break;

	case kt_obsolete:
		break;
	}

	return ok;
}

static bool translate_leftright(struct starter_conn *conn,
				const struct config_parsed *cfgp,
				const struct section_list *sl,
				enum keyword_set assigned_value,
				const struct kw_list *kw,
				struct starter_end *this,
				struct logger *logger)
{
	return translate_field(conn, cfgp, sl, assigned_value, kw,
			       /*leftright*/this->leftright,
			       this->values,
			       logger);
}

static bool translate_conn(struct starter_conn *conn,
			   const struct config_parsed *cfgp,
			   struct section_list *sl,
			   enum keyword_set assigned_value,
			   struct logger *logger)
{
	if (sl->beenhere) {
		ldbg(logger, "ignore duplicate include");
		return true; /* ok */
	}

	sl->beenhere = true;

	/*
	 * Note: not all errors are considered serious (see above).
	 */
	bool ok = true;

	for (const struct kw_list *kw = sl->kw; kw != NULL; kw = kw->next) {
		if ((kw->keyword.keydef->validity & kv_leftright) ||
		    (kw->keyword.keydef->validity & kv_both)) {
			if (kw->keyword.keyleft) {
				ok &= translate_leftright(conn, cfgp, sl, assigned_value,
							  kw, &conn->end[LEFT_END],
							  logger);
			}
			if (kw->keyword.keyright) {
				ok &= translate_leftright(conn, cfgp, sl, assigned_value,
							  kw, &conn->end[RIGHT_END],
							  logger);
			}
		} else {
			ok &= translate_field(conn, cfgp, sl, assigned_value, kw,
					      /*leftright*/"",
					      conn->values,
					      logger);
		}
	}

	return ok;
}

static bool load_conn(struct starter_conn *conn,
		      const struct config_parsed *cfgp,
		      struct section_list *sl,
		      bool alsoprocessing,
		      bool defaultconn,
		      struct logger *logger)
{
	/* reset all of the "beenhere" flags */
	struct section_list *s;
	TAILQ_FOREACH(s, &cfgp->sections, link) {
		s->beenhere = false;
	}

	/*
	 * Turn all of the keyword/value pairs into options/strings in
	 * left/right.
	 *
	 * DANGER: returns false on success.
	 */
	if (!translate_conn(conn, cfgp, sl,
			    defaultconn ? k_default : k_set,
			    logger)) {
		return false;
	}

	if (conn->values[KSCF_ALSO].string != NULL &&
	    !alsoprocessing) {
		llog(RC_LOG, logger, "also= is not valid in section '%s'",
		     sl->name);
		return false;	/* error */
	}

	if (conn->values[KNCF_TYPE].set) {
		switch ((enum type_options)conn->values[KNCF_TYPE].option) {
		case KS_UNSET:
			bad_case(KS_UNSET);

		case KS_TUNNEL:
			break;

		case KS_TRANSPORT:
			break;

		case KS_PASSTHROUGH:
			conn->never_negotiate_shunt = SHUNT_PASS;
			break;

		case KS_DROP:
			conn->never_negotiate_shunt = SHUNT_DROP;
			break;

		case KS_REJECT:
			llog(RC_LOG, logger, "warning: type=%%reject implemented as type=%%drop");
			conn->never_negotiate_shunt = SHUNT_DROP;
			break;
		}
	}

	conn->negotiation_shunt = conn->values[KNCF_NEGOTIATIONSHUNT].option;
	conn->failure_shunt = conn->values[KNCF_FAILURESHUNT].option;

	/*
	 * TODO:
	 * The address family default should come in either via
	 * a config setup option, or via gai.conf / RFC3484
	 * For now, %defaultroute and %any means IPv4 only
	 */

	const struct ip_info *host_afi = NULL;
	const char *hostaddrfamily = conn->values[KWS_HOSTADDRFAMILY].string;
	if (hostaddrfamily != NULL) {
		host_afi = ttoinfo(hostaddrfamily);
		if (host_afi == NULL) {
			llog(RC_LOG, logger, "hostaddrfamily=%s is not recognized",
			     hostaddrfamily);
			/* stumble on, pluto should reject it */
		}
	}
	if (host_afi == NULL) {
		FOR_EACH_THING(end, &conn->end[LEFT_END], &conn->end[RIGHT_END]) {
			FOR_EACH_THING(ips,
				       end->values[KW_IP].string,
				       end->values[KW_NEXTHOP].string) {
				if (ips == NULL) {
					continue;
				}
				/* IPv6 like address */
				if (strchr(ips, ':') != NULL ||
				    streq(ips, "%defaultroute6") ||
				    streq(ips, "%any6")) {
					host_afi = &ipv6_info;
					break;
				}
			}
			if (host_afi != NULL) {
				break;
			}
		}
	}
	if (host_afi == NULL) {
		host_afi = &ipv4_info;
	}
	conn->host_afi = host_afi;

	return true;
}

static void copy_conn_default(struct starter_conn *conn,
			      const struct starter_conn *def)
{
	/* structure copy to start */
	*conn = *def;

	/* unlink it */
	conn->link.tqe_next = NULL;
	conn->link.tqe_prev = NULL;

	/* Unshare all strings */

	/*
	 * Note: string fields in struct starter_end and struct starter_conn
	 * should correspond to STR_FIELD calls in copy_conn_default() and confread_free_conn.
	 */

# define STR_FIELD(f)  { conn->f = clone_str(conn->f, #f); }

	STR_FIELD(name);

	for (unsigned i = 0; i < elemsof(conn->values); i++)
		STR_FIELD(values[i].string);

	/* handle starter_end strings */

# define STR_FIELD_END(f) { STR_FIELD(end[LEFT_END].f); STR_FIELD(end[RIGHT_END].f); }

	for (unsigned i = 0; i < elemsof(conn->end[LEFT_END].values); i++)
		STR_FIELD_END(values[i].string);

# undef STR_FIELD_END

# undef STR_FIELD
}

static struct starter_conn *alloc_add_conn(struct starter_config *cfg, const char *name)
{
	struct starter_conn *conn = alloc_thing(struct starter_conn, "add_conn starter_conn");

	copy_conn_default(conn, &cfg->conn_default);
	assert(conn->name == NULL);
	conn->name = clone_str(name, "add conn name");
	conn->state = STATE_FAILED;

	TAILQ_INSERT_TAIL(&cfg->conns, conn, link);
	return conn;
}

struct starter_config *confread_load(const char *file,
				     bool setuponly,
				     struct logger *logger,
				     unsigned verbosity)
{
	/**
	 * Load file
	 */
	struct config_parsed *cfgp = parser_load_conf(file, logger, setuponly, verbosity);
	if (cfgp == NULL)
		return NULL;

	struct starter_config *cfg = alloc_starter_config();

	/**
	 * Load setup
	 *
	 * Danger: reverse fail.
	 */
	if (!load_setup(cfg, cfgp)) {
		parser_freeany_config_parsed(&cfgp);
		confread_free(cfg);
		return NULL;
	}

	if (!setuponly) {
		struct section_list *sconn;

		/*
		 * Load %default conn
		 *
		 * ??? is it correct to accept multiple %default conns?
		 *
		 * XXX: yes, apparently it's a feature
		 */
		TAILQ_FOREACH(sconn, &cfgp->sections, link) {
			if (streq(sconn->name, "%default")) {
				/*
				 * Is failing to load default conn
				 * fatal?
				 */
				ldbg(logger, "loading default conn");
				if (!load_conn(&cfg->conn_default,
					       cfgp, sconn,
					       /*also=*/false,
					       /*default conn*/true,
					       logger)) {
					break;
				}
				/* validate each update?!? */
				if (!confread_validate_conn(&cfg->conn_default, logger)) {
					break;
				}
			}
		}

		/*
		 * Load other conns
		 */
		TAILQ_FOREACH(sconn, &cfgp->sections, link) {
			if (streq(sconn->name, "%default")) {
				/* %default processed above */
				continue;
			}

			ldbg(logger, "loading conn %s", sconn->name);
			struct starter_conn *conn = alloc_add_conn(cfg, sconn->name);
			if (!load_conn(conn, cfgp, sconn,
				       /*also*/true,
				       /*default-conn*/false,
				       logger)) {
				/* ??? should caller not log perrl? */
				continue;
			}

			conn->state = STATE_LOADED;
		}
	}

	parser_freeany_config_parsed(&cfgp);
	return cfg;
}

struct starter_config *confread_argv(const char *name,
				     char *argv[], int start,
				     struct logger *logger)
{
	/**
	 * Load file
	 */
	struct config_parsed *cfgp = parser_argv_conf(name, argv, start, logger);
	if (cfgp == NULL)
		return NULL;

	struct starter_config *cfg = alloc_starter_config();
	if (cfg == NULL) {
		parser_freeany_config_parsed(&cfgp);
		return NULL;
	}

	/*
	 * Load other conns
	 */

	struct section_list *sconn = TAILQ_FIRST(&cfgp->sections);
	struct starter_conn *conn = alloc_add_conn(cfg, sconn->name);
	if (!load_conn(conn, cfgp, sconn,
		       /*also*/true,
		       /*default conn*/false,
		       logger)) {
	    parser_freeany_config_parsed(&cfgp);
	    /* XXX: leak! */
	    return NULL;
	}

	parser_freeany_config_parsed(&cfgp);
	return cfg;
}

static void confread_free_conn_content(struct starter_conn *conn)
{
	/* Free all strings */

	/*
	 * Note: string fields in struct starter_end and struct starter_conn
	 * should correspond to STR_FIELD calls in copy_conn_default() and confread_free_conn.
	 */

# define STR_FIELD(f)  { pfreeany(conn->f); }

	STR_FIELD(name);

	for (unsigned i = 0; i < elemsof(conn->values); i++)
		STR_FIELD(values[i].string);

	/* handle starter_end strings */

# define STR_FIELD_END(f) { STR_FIELD(end[LEFT_END].f); STR_FIELD(end[RIGHT_END].f); }

	for (unsigned i = 0; i < elemsof(conn->end[LEFT_END].values); i++)
		STR_FIELD_END(values[i].string);

# undef STR_FIELD_END

# undef STR_FIELD
}

void confread_free(struct starter_config *cfg)
{
	for (unsigned i = 0; i < elemsof(cfg->setup); i++) {
		pfreeany(cfg->setup[i].string);
	}

	confread_free_conn_content(&cfg->conn_default);

	struct starter_conn *conn;
	while ((conn = TAILQ_FIRST(&cfg->conns)) != NULL) {
		TAILQ_REMOVE(&cfg->conns, conn, link);
		confread_free_conn_content(conn);
		pfree(conn);
	}

	pfree(cfg);
}
