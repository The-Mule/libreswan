/*
 * Libreswan config file parser (keywords.c)
 * Copyright (C) 2003-2006 Michael Richardson <mcr@xelerance.com>
 * Copyright (C) 2007-2010 Paul Wouters <paul@xelerance.com>
 * Copyright (C) 2012 Paul Wouters <paul@libreswan.org>
 * Copyright (C) 2013-2019 Paul Wouters <pwouters@redhat.com>
 * Copyright (C) 2013-2019 D. Hugh Redelmeier <hugh@mimosa.com>
 * Copyright (C) 2013 David McCullough <ucdevel@gmail.com>
 * Copyright (C) 2013-2016 Antony Antony <antony@phenome.org>
 * Copyright (C) 2016-2022 Andrew Cagney
 * Copyright (C) 2017 Mayank Totale <mtotale@gmail.com>
 * Copyright (C) 2020 Yulia Kuzovkova <ukuzovkova@gmail.com>
 * Copyright (C) 2020 Nupur Agrawal <nupur202000@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.  See <https://www.gnu.org/licenses/gpl2.txt>.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 */

#include <string.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <sys/socket.h>		/* for AF_INET/AF_INET6 */

#include "constants.h"
#include "lmod.h"
#include "lswcdefs.h"		/* for elemsof() */
#include "sparse_names.h"
#include "encap_proto.h"
#include "ocsp_method.h"
#include "lswalloc.h"
#include "shunt.h"
#include "xauthby.h"
#include "xauthfail.h"
#include "global_redirect.h"
#ifdef USE_SECCOMP
#include "seccomp_mode.h"
#endif
#include "ddos_mode.h"

#include "ipsecconf/keywords.h"
#include "ipsecconf/parser.h"	/* includes parser.tab.h generated by bison; requires keywords.h */

/*
 * Common aliases for YES and NO, add this to a keyword list so all
 * are accepted.
 *
 * This list does not include "0" or "1" as they, for things like
 * yndev have special meanings.
 */
#define YES_NO(YES, NO)				\
	SPARSE("yes",        YES),		\
		SPARSE("no",         NO),	\
		SPARSE("true",       YES),	\
		SPARSE("false",      NO),	\
		SPARSE("on",         YES),	\
		SPARSE("off",        NO),	\
		SPARSE("y",          YES),	\
		SPARSE("n",          NO)

/*
 * Values for right= and left=
 */

static const struct sparse_names kw_phase2types_names = {
	.list = {
		/* note: these POLICY bits happen to fit in an unsigned int */
		/* note2: ah+esp is no longer supported as per RFC-8221 Section 4 */
		SPARSE("esp",      ENCAP_PROTO_ESP),
		SPARSE("ah",       ENCAP_PROTO_AH),
		SPARSE("default",  ENCAP_PROTO_UNSET), /* i.e., let pluto decide */
		SPARSE_NULL
	},
};

/*
 * MASTER KEYWORD LIST
 */

static const struct keyword_def config_setup_keyword[] = {
#define K(KEYNAME, VALIDITY, TYPE, FIELD, SPARSE_NAME) [FIELD] = { KEYNAME, VALIDITY, TYPE, FIELD, SPARSE_NAME }

  K("ikev1-policy",  kv_config,  kt_sparse_name,  KBF_IKEv1_POLICY, &global_ikev1_policy_names),
  K("curl-iface",  kv_config,  kt_string,  KSF_CURLIFACE, NULL),

  K("myvendorid",  kv_config,  kt_string,  KSF_MYVENDORID, NULL),

  K("plutodebug",  kv_config, kt_string, KSF_PLUTODEBUG, NULL),

  K("logfile",  kv_config,  kt_string,  KSF_LOGFILE, NULL),
  K("logtime",  kv_config,  kt_sparse_name,  KYN_LOGTIME, &yn_option_names),
  K("logappend",  kv_config,  kt_sparse_name,  KYN_LOGAPPEND, &yn_option_names),
  K("logip",  kv_config,  kt_sparse_name,  KYN_LOGIP, &yn_option_names),
  K("audit-log",  kv_config,  kt_sparse_name,  KYN_AUDIT_LOG, &yn_option_names),
#ifdef USE_DNSSEC
  K("dnssec-enable",  kv_config,  kt_sparse_name,  KYN_DNSSEC_ENABLE, &yn_option_names),
  K("dnssec-rootkey-file",  kv_config,  kt_string, KSF_DNSSEC_ROOTKEY_FILE, NULL),
  K("dnssec-anchors",  kv_config,  kt_string, KSF_DNSSEC_ANCHORS, NULL),
#endif
  K("dumpdir",  kv_config,  kt_string,  KSF_DUMPDIR, NULL),
  K("ipsecdir",  kv_config,  kt_string,  KSF_IPSECDIR, NULL),
  K("nssdir", kv_config, kt_string, KSF_NSSDIR, NULL),
  K("rundir", kv_config|kv_ignore, kt_string, KSF_RUNDIR, NULL),
  K("logstderr", kv_config|kv_ignore, kt_string, KYN_LOGSTDERR, NULL),
  K("secretsfile",  kv_config,  kt_string,  KSF_SECRETSFILE, NULL),
  K("statsbin",  kv_config,  kt_string,  KSF_STATSBIN, NULL),
  K("uniqueids",  kv_config,  kt_sparse_name,  KYN_UNIQUEIDS, &yn_option_names),
  K("shuntlifetime",  kv_config,  kt_seconds,  KBF_SHUNTLIFETIME, NULL),

  K("global-redirect", kv_config, kt_sparse_name, KBF_GLOBAL_REDIRECT, &global_redirect_names),
  K("global-redirect-to", kv_config, kt_string, KSF_GLOBAL_REDIRECT_TO, NULL),

  K("crl-strict",  kv_config,  kt_sparse_name,  KYN_CRL_STRICT, &yn_option_names),
  K("crlcheckinterval",  kv_config,  kt_seconds,  KBF_CRL_CHECKINTERVAL, NULL),
  K("crl-timeout",  kv_config,  kt_seconds,  KBF_CRL_TIMEOUT_SECONDS, NULL),

  K("ocsp-strict",  kv_config,  kt_sparse_name,  KYN_OCSP_STRICT, &yn_option_names),
  K("ocsp-enable",  kv_config,  kt_sparse_name,  KYN_OCSP_ENABLE, &yn_option_names),
  K("ocsp-uri",  kv_config,  kt_string,  KSF_OCSP_URI, NULL),
  K("ocsp-timeout",  kv_config,  kt_seconds,  KBF_OCSP_TIMEOUT_SECONDS, NULL),
  K("ocsp-trustname",  kv_config,  kt_string,  KSF_OCSP_TRUSTNAME, NULL),
  K("ocsp-cache-size",  kv_config,  kt_unsigned,  KBF_OCSP_CACHE_SIZE, NULL),
  K("ocsp-cache-min-age",  kv_config,  kt_seconds,  KBF_OCSP_CACHE_MIN_AGE_SECONDS, NULL),
  K("ocsp-cache-max-age",  kv_config,  kt_seconds,  KBF_OCSP_CACHE_MAX_AGE_SECONDS, NULL),
  K("ocsp-method",  kv_config,  kt_sparse_name,  KBF_OCSP_METHOD, &ocsp_method_names),

#ifdef USE_SECCOMP
  K("seccomp",  kv_config,  kt_sparse_name,  KBF_SECCOMP,  &seccomp_mode_names),
#endif

  K("ddos-mode",  kv_config,  kt_sparse_name,  KBF_DDOS_MODE, &ddos_mode_names),
  K("ddos-ike-threshold",  kv_config,  kt_unsigned,  KBF_DDOS_IKE_THRESHOLD, NULL),
  K("max-halfopen-ike",  kv_config,  kt_unsigned,  KBF_MAX_HALFOPEN_IKE, NULL),

  K("ike-socket-bufsize",  kv_config,  kt_unsigned,  KBF_IKE_SOCKET_BUFSIZE, NULL),
  K("ike-socket-errqueue",  kv_config,  kt_sparse_name,  KYN_IKE_SOCKET_ERRQUEUE, &yn_option_names),
#ifdef XFRM_LIFETIME_DEFAULT
  K("expire-lifetime",  kv_config,  kt_seconds,  KBF_EXPIRE_LIFETIME, NULL),
#endif
  K("virtual-private",  kv_config,  kt_string,  KSF_VIRTUAL_PRIVATE, NULL),
  K("seedbits",  kv_config,  kt_unsigned,  KBF_SEEDBITS, NULL),
  K("keep-alive",  kv_config,  kt_seconds,  KBF_KEEP_ALIVE, NULL),

  K("listen-tcp", kv_config, kt_sparse_name, KYN_LISTEN_TCP, &yn_option_names),
  K("listen-udp", kv_config, kt_sparse_name, KYN_LISTEN_UDP, &yn_option_names),

  K("listen",  kv_config,  kt_string,  KSF_LISTEN, NULL),
  K("protostack",  kv_config,  kt_string,  KSF_PROTOSTACK,  NULL),
  K("nhelpers",  kv_config,  kt_unsigned,  KBF_NHELPERS, NULL),
  K("drop-oppo-null",  kv_config,  kt_sparse_name,  KYN_DROP_OPPO_NULL, &yn_option_names),
  K("expire-shunt-interval", kv_config, kt_seconds, KSF_EXPIRE_SHUNT_INTERVAL, NULL),

  K("ipsec-interface-managed", kv_config, kt_sparse_name, KYN_IPSEC_INTERFACE_MANAGED, &yn_option_names),

#ifdef USE_NFLOG
  K("nflog-all",  kv_config,  kt_unsigned,  KBF_NFLOG_ALL, NULL),
#endif

  /*
   * Force first alias/obsolete keyword into slot following all
   * defined keywords.  Else compiler tries to store it into above
   * keyword's slot + 1, which is likely occupied by another keyword.
   * The result is a nonsensical error.
   */
  [CONFIG_SETUP_KEYWORD_ROOF] =

  /* alias for compatibility - undocumented on purpose */

  { "curl-timeout",  kv_config | kv_alias,  kt_seconds,  KBF_CRL_TIMEOUT_SECONDS, NULL, }, /* legacy */
#ifdef XFRM_LIFETIME_DEFAULT
  { "xfrmlifetime",  kv_config | kv_alias,  kt_seconds,  KBF_EXPIRE_LIFETIME, NULL, }, /* legacy */
#endif

  /* obsolete config setup options */

  { "syslog",  kv_config,  kt_obsolete,  KNCF_OBSOLETE, NULL, }, /* never went anywhere! */
  { "plutostderrlog",  kv_config,  kt_obsolete,  KNCF_OBSOLETE, NULL, }, /* obsolete name, but very common :/ */
  { "virtual_private",  kv_config,  kt_obsolete,  KNCF_OBSOLETE, NULL, }, /* obsolete variant, very common */
  { "interfaces",  kv_config, kt_obsolete, KNCF_OBSOLETE, NULL, }, /* obsoleted but often present keyword */

  { "ikev1-secctx-attr-type",  kv_config,  kt_obsolete,  KNCF_OBSOLETE, NULL, },  /* obsolete: not a value, a type */
  { "secctx-attr-type",  kv_config,  kt_obsolete,  KNCF_OBSOLETE, NULL, },

};

static const struct keyword_def config_conn_keyword[] = {

  /*
   * This is "left=" and "right="
   */
  K("",  kv_conn | kv_leftright,  kt_string,  KWS_HOST, NULL),

  K("debug",       kv_conn, kt_string, KWS_DEBUG, NULL),

  K("subnet",  kv_conn | kv_leftright,  kt_string,  KWS_SUBNET, NULL),
  K("subnets",  kv_conn | kv_leftright,  kt_appendlist,  KSCF_SUBNETS, NULL),
  K("sourceip",  kv_conn | kv_leftright,  kt_string,  KWS_SOURCEIP, NULL),
  K("ikeport",  kv_conn | kv_leftright,  kt_string,  KWS_IKEPORT, NULL),
  K("interface-ip", kv_conn | kv_leftright,  kt_string, KWS_INTERFACE_IP, NULL),
  K("vti",  kv_conn | kv_leftright,  kt_string,  KWS_VTI, NULL),
  K("nexthop",  kv_conn | kv_leftright,  kt_string,  KWS_NEXTHOP, NULL),
  K("updown",  kv_conn | kv_leftright,  kt_string,  KWS_UPDOWN, NULL),
  K("id",  kv_conn | kv_leftright,  kt_string,  KWS_ID, NULL),

  /*
   * Note: these are merged into .pubkey + .pubkey_alg before sending
   * to pluto.
   */
  K("rsasigkey",  kv_conn | kv_leftright,  kt_string,  KWS_RSASIGKEY, NULL),
  K("ecdsakey",  kv_conn | kv_leftright,  kt_string,  KWS_ECDSAKEY, NULL),
  K("pubkey",  kv_conn | kv_leftright,  kt_string,  KWS_PUBKEY, NULL),

  K("cert",  kv_conn | kv_leftright,  kt_string,  KWS_CERT, NULL),
  K("ckaid",  kv_conn | kv_leftright,  kt_string,  KWS_CKAID, NULL),
  K("sendcert",  kv_conn | kv_leftright,  kt_string,  KWS_SENDCERT, NULL),
  K("ca",  kv_conn | kv_leftright,  kt_string,  KWS_CA, NULL),
  K("xauthserver",  kv_conn | kv_leftright,  kt_sparse_name,  KWYN_XAUTHSERVER, &yn_option_names),
  K("xauthclient",  kv_conn | kv_leftright,  kt_sparse_name,  KWYN_XAUTHCLIENT, &yn_option_names),
  K("modecfgserver",  kv_conn | kv_leftright,  kt_sparse_name,  KWYN_MODECONFIGSERVER, &yn_option_names),
  K("modecfgclient",  kv_conn | kv_leftright,  kt_sparse_name,  KWYN_MODECONFIGCLIENT, &yn_option_names),
  K("username",  kv_conn | kv_leftright,  kt_string,  KWS_USERNAME, NULL),
  K("addresspool",  kv_conn | kv_leftright,  kt_string,  KWS_ADDRESSPOOL, NULL),
  K("auth",  kv_conn | kv_leftright, kt_string,  KWS_AUTH, NULL),
#ifdef USE_CAT
  K("cat",  kv_conn | kv_leftright,  kt_sparse_name,  KWYN_CAT, &yn_option_names),
#endif
  K("protoport",  kv_conn | kv_leftright,  kt_string,  KWS_PROTOPORT, NULL),
  K("autheap",  kv_conn | kv_leftright,  kt_string,  KWS_AUTHEAP, NULL),
  K("groundhog",  kv_conn | kv_leftright,  kt_sparse_name,  KWYN_GROUNDHOG, &yn_option_names),

  /* these are conn statements which are not left/right */

  K("auto",  kv_conn,  kt_sparse_name,  KNCF_AUTO, &autostart_names),
  K("also",  kv_conn | kv_duplicateok,  kt_also,  KSCF_ALSO, NULL),
  K("hostaddrfamily",  kv_conn,  kt_string,  KWS_HOSTADDRFAMILY, NULL),
  K("type",  kv_conn,  kt_sparse_name,  KNCF_TYPE, &type_option_names),
  K("authby",  kv_conn,  kt_string,  KWS_AUTHBY, NULL),
  K("keyexchange",  kv_conn,  kt_string,  KWS_KEYEXCHANGE, NULL),
  K("ikev2",  kv_conn,  kt_string,  KWS_IKEv2, NULL),
  K("ppk", kv_conn, kt_sparse_name, KNCF_PPK, &nppi_option_names),
  K("ppk-ids", kv_conn, kt_string, KWS_PPK_IDS, NULL),
  K("intermediate",  kv_conn, kt_sparse_name, KWYN_INTERMEDIATE, &yn_option_names),
  K("esn",  kv_conn,  kt_sparse_name,  KNCF_ESN, &yne_option_names),
  K("decap-dscp",  kv_conn,  kt_sparse_name,  KWYN_DECAP_DSCP, &yn_option_names),
  K("encap-dscp",  kv_conn,  kt_sparse_name,  KWYN_ENCAP_DSCP, &yn_option_names),
  K("nopmtudisc",  kv_conn,  kt_sparse_name,  KWYN_NOPMTUDISC, &yn_option_names),
  K("fragmentation",  kv_conn,  kt_sparse_name,  KNCF_FRAGMENTATION, &ynf_option_names),
  K("mobike",  kv_conn,  kt_sparse_name,  KWYN_MOBIKE, &yn_option_names),
  K("narrowing",  kv_conn,  kt_sparse_name,  KWYN_NARROWING, &yn_option_names),
  K("pam-authorize",  kv_conn,  kt_sparse_name,  KWYN_PAM_AUTHORIZE, &yn_option_names),
  K("send-redirect",  kv_conn,  kt_sparse_name,  KNCF_SEND_REDIRECT, &yna_option_names),
  K("redirect-to",  kv_conn,  kt_string,  KWS_REDIRECT_TO, NULL),
  K("accept-redirect",  kv_conn,  kt_sparse_name, KWYN_ACCEPT_REDIRECT, &yn_option_names),
  K("accept-redirect-to",  kv_conn,  kt_string, KWS_ACCEPT_REDIRECT_TO, NULL),
  K("pfs",  kv_conn,  kt_sparse_name,  KWYN_PFS, &yn_option_names),
  K("session-resumption",  kv_conn,  kt_sparse_name,  KWYN_SESSION_RESUMPTION, &yn_option_names),

  K("nat-keepalive",  kv_conn,  kt_sparse_name,  KWYN_NAT_KEEPALIVE, &yn_option_names),

  K("initial-contact",  kv_conn,  kt_sparse_name,  KWYN_INITIAL_CONTACT, &yn_option_names),
  K("send-esp-tfc-padding-not-supported",  kv_conn,  kt_sparse_name,  KWYN_SEND_ESP_TFC_PADDING_NOT_SUPPORTED, &yn_option_names),

  K("iptfs",  kv_conn,  kt_sparse_name,  KWYN_IPTFS, &yn_option_names),
  K("iptfs-fragmentation",  kv_conn,  kt_sparse_name,  KWYN_IPTFS_FRAGMENTATION, &yn_option_names),
  K("iptfs-packet-size",  kv_conn,  kt_string,  KWS_IPTFS_PACKET_SIZE, NULL),
  K("iptfs-max-queue-size",  kv_conn,  kt_string,  KWS_IPTFS_MAX_QUEUE_SIZE, NULL),
  K("iptfs-reorder-window",  kv_conn,  kt_string,  KWS_IPTFS_REORDER_WINDOW, NULL),
  K("iptfs-init-delay",  kv_conn,  kt_seconds,  KNCF_IPTFS_INIT_DELAY, NULL),
  K("iptfs-drop-time",  kv_conn,  kt_seconds,  KNCF_IPTFS_DROP_TIME, NULL),

  K("fake-strongswan",  kv_conn,  kt_sparse_name,  KWYN_FAKE_STRONGSWAN, &yn_option_names),
  K("send-vendorid",  kv_conn,  kt_sparse_name,  KWYN_SEND_VENDORID, &yn_option_names),
  K("sha2-truncbug",  kv_conn,  kt_sparse_name,  KWYN_SHA2_TRUNCBUG, &yn_option_names),
  K("share-lease",  kv_conn,  kt_sparse_name,  KWYN_SHARE_LEASE, &yn_option_names),
  K("ms-dh-downgrade",  kv_conn,  kt_sparse_name,  KWYN_MS_DH_DOWNGRADE, &yn_option_names),
  K("pfs-rekey-workaround",  kv_conn,  kt_sparse_name,  KWYN_PFS_REKEY_WORKAROUND, &yn_option_names),
  K("require-id-on-certificate",  kv_conn,  kt_sparse_name,  KWYN_REQUIRE_ID_ON_CERTIFICATE, &yn_option_names),
  K("dns-match-id,",  kv_conn,  kt_sparse_name,  KWYN_DNS_MATCH_ID, &yn_option_names),
  K("ipsec-max-bytes",  kv_conn,  kt_string,  KWS_IPSEC_MAX_BYTES, NULL),
  K("ipsec-max-packets",  kv_conn,  kt_string,  KWS_IPSEC_MAX_PACKETS, NULL),
  K("ipsec-lifetime",  kv_conn,  kt_seconds,  KNCF_IPSEC_LIFETIME, NULL),

  K("retransmit-timeout",  kv_conn,  kt_seconds,  KNCF_RETRANSMIT_TIMEOUT, NULL),
  K("retransmit-interval",  kv_conn,  kt_string,  KWS_RETRANSMIT_INTERVAL, NULL),

  K("ikepad",  kv_conn,  kt_sparse_name,  KNCF_IKEPAD, &yna_option_names),
  K("nat-ikev1-method",  kv_conn,  kt_sparse_name,  KNCF_NAT_IKEv1_METHOD, &nat_ikev1_method_option_names),

  K("sec-label",  kv_conn,  kt_string,  KWS_SEC_LABEL, NULL),

  /* Cisco interop: remote peer type */
  K("remote-peer-type",  kv_conn,  kt_string,  KWS_REMOTE_PEER_TYPE, NULL),
  /* Network Manager support */
  K("nm-configured",  kv_conn,  kt_string,  KWS_NM_CONFIGURED, NULL),
  K("cisco-unity",  kv_conn,  kt_string,  KWS_CISCO_UNITY, NULL),
  K("cisco-split",  kv_conn,  kt_string,  KWS_CISCO_SPLIT, NULL),

  K("xauthby",  kv_conn,  kt_sparse_name,  KNCF_XAUTHBY, &xauthby_names),
  K("xauthfail",  kv_conn,  kt_sparse_name,  KNCF_XAUTHFAIL, &xauthfail_names),
  K("modecfgpull",  kv_conn,  kt_sparse_name,  KWYN_MODECFGPULL, &yn_option_names),
  K("modecfgdns",  kv_conn,  kt_string,  KWS_MODECFGDNS, NULL),
  K("modecfgdomains",  kv_conn,  kt_string,  KWS_MODECFGDOMAINS, NULL),
  K("modecfgbanner",  kv_conn,  kt_string,  KWS_MODECFGBANNER, NULL),
  K("ignore-peer-dns",  kv_conn,  kt_sparse_name,  KWYN_IGNORE_PEER_DNS, &yn_option_names),
  K("mark",  kv_conn,  kt_string,  KWS_MARK, NULL),
  K("mark-in",  kv_conn,  kt_string,  KWS_MARK_IN, NULL),
  K("mark-out",  kv_conn,  kt_string,  KWS_MARK_OUT, NULL),
  K("vti-interface",  kv_conn,  kt_string,  KWS_VTI_INTERFACE, NULL),
  K("vti-routing",  kv_conn,  kt_sparse_name,  KWYN_VTI_ROUTING, &yn_option_names),
  K("vti-shared",  kv_conn,  kt_sparse_name,  KWYN_VTI_SHARED, &yn_option_names),
  K("ipsec-interface", kv_conn, kt_string, KWS_IPSEC_INTERFACE, NULL),

  K("nic-offload",  kv_conn,  kt_sparse_name,  KNCF_NIC_OFFLOAD, &nic_offload_option_names),

  K("encapsulation",  kv_conn,  kt_sparse_name,  KNCF_ENCAPSULATION, &yna_option_names),

  K("overlapip",  kv_conn,  kt_sparse_name,  KWYN_OVERLAPIP, &yn_option_names),
  K("reauth",  kv_conn,  kt_sparse_name,  KWYN_REAUTH, &yn_option_names),
  K("rekey",  kv_conn,  kt_sparse_name,  KWYN_REKEY, &yn_option_names),
  K("rekeymargin",  kv_conn,  kt_seconds,  KNCF_REKEYMARGIN, NULL),
  K("rekeyfuzz",  kv_conn,  kt_string,  KWS_REKEYFUZZ, NULL),
  K("replay-window",  kv_conn,  kt_string,  KWS_REPLAY_WINDOW, NULL),
  K("ikelifetime",  kv_conn,  kt_seconds,  KNCF_IKELIFETIME, NULL),
  K("failureshunt",  kv_conn,  kt_sparse_name,  KNCF_FAILURESHUNT, &failure_shunt_names),
  K("negotiationshunt",  kv_conn,  kt_sparse_name,  KNCF_NEGOTIATIONSHUNT, &negotiation_shunt_names),

  K("enable-tcp",  kv_conn, kt_sparse_name, KNCF_ENABLE_TCP, &tcp_option_names),
  K("tcp-remoteport",  kv_conn, kt_unsigned, KNCF_TCP_REMOTEPORT, NULL),

  K("connalias",  kv_conn,  kt_appendstring,  KSCF_CONNALIAS, NULL),

  /* attributes of the phase2 policy */
  K("ike",  kv_conn,  kt_string, KWS_IKE, NULL),
  K("esp",  kv_conn,  kt_string, KWS_ESP, NULL),
  K("ah",  kv_conn,  kt_string, KWS_AH, NULL),
  K("phase2",  kv_conn,  kt_sparse_name,  KNCF_PHASE2, &kw_phase2types_names), /*obsolete*/
  K("phase2alg", kv_conn,  kt_string, KWS_PHASE2ALG, NULL), /* obsolete */

  K("compress",  kv_conn,  kt_sparse_name,  KWYN_COMPRESS, &yn_option_names),

  /* route metric */
  K("metric",  kv_conn,  kt_unsigned,  KNCF_METRIC, NULL),

  /* DPD */
  K("dpddelay",  kv_conn,  kt_string,  KWS_DPDDELAY, NULL),
  K("ikev1-dpdtimeout",  kv_conn,  kt_string,  KWS_DPDTIMEOUT, NULL),

  K("sendca",      kv_conn,  kt_string,  KWS_SENDCA, NULL),

  K("mtu",  kv_conn,  kt_string,  KWS_MTU, NULL),
  K("priority",  kv_conn,  kt_string,  KWS_PRIORITY, NULL),
  K("tfc",  kv_conn,  kt_string,  KWS_TFC, NULL),
  K("reqid",  kv_conn,  kt_string,  KWS_REQID, NULL),
#ifdef USE_NFLOG
  K("nflog-group",  kv_conn,  kt_string,  KWS_NFLOG_GROUP, NULL),
#endif

  K("aggressive",  kv_conn,  kt_sparse_name,  KWYN_AGGRESSIVE, &yn_option_names),

#undef K

  /*
   * Force first alias/obsolete keyword into slot following all
   * defined keywords.  Else compiler tries to store it into above
   * keyword's slot + 1, which is likely occupied by another keyword.
   * The result is a nonsensical error.
   */
  [CONFIG_CONN_KEYWORD_ROOF] =

  /* alias for compatibility - undocumented on purpose */

  { "aggrmode",  kv_conn | kv_alias,  kt_sparse_name,  KWYN_AGGRESSIVE, &yn_option_names, },
  { "keylife",  kv_conn | kv_alias,  kt_seconds,  KNCF_IPSEC_LIFETIME, NULL, }, /* old name */
  { "lifetime",  kv_conn | kv_alias,  kt_seconds,  KNCF_IPSEC_LIFETIME, NULL, }, /* old name */
  { "dpdtimeout",  kv_conn | kv_alias,  kt_string,  KWS_DPDTIMEOUT, NULL, }, /* old name */
#ifdef USE_NFLOG
  { "nflog",  kv_conn | kv_alias,  kt_string,  KWS_NFLOG_GROUP, NULL, }, /* old-name */
#endif
  { "salifetime",  kv_conn | kv_alias,  kt_seconds,  KNCF_IPSEC_LIFETIME, NULL, }, /* old name */
  /* xauthusername is still used in NetworkManager-libreswan :/ */
  { "xauthusername",  kv_conn | kv_leftright | kv_alias,  kt_string,  KWS_USERNAME, NULL, }, /* old alias */
  { "policy-label",  kv_conn | kv_alias,  kt_string,  KWS_SEC_LABEL, NULL, }, /* obsolete variant */
  /* another alias used by NetworkManager-libreswan :/ */
  { "remote_peer_type",  kv_conn | kv_alias,  kt_string,  KWS_REMOTE_PEER_TYPE, NULL, },
  { "send-no-esp-tfc",  kv_conn | kv_alias,  kt_sparse_name,  KWYN_SEND_ESP_TFC_PADDING_NOT_SUPPORTED, &yn_option_names, }, /*compat, but forever*/

  /* obsolete config setup options */

  { "dpdaction",  kv_conn,  kt_obsolete,  KNCF_OBSOLETE,  NULL, },
  { "clientaddrfamily",  kv_conn,  kt_obsolete,  KNCF_OBSOLETE, NULL, },
  { "keyingtries",  kv_conn,  kt_obsolete,  KNCF_OBSOLETE, NULL, },

};

const struct keywords_def config_setup_keywords = {
	.len = elemsof(config_setup_keyword),
	.item = config_setup_keyword,
};

const struct keywords_def config_conn_keywords = {
	.len = elemsof(config_conn_keyword),
	.item = config_conn_keyword,
};
